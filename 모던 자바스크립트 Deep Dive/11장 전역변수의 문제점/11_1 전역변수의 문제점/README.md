# 전역 변수의 문제점
전역 변수의 무분별한 사용은 위험하다. 전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 한다.

## 변수의 생명 주기
변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠가 소멸한다. 변수는 생물과 유사하게 생성되고 소멸되는 생명 주기가 있다.
- 변수는 자신이 선언된 위치에서 생성되고 소멸한다. 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같다 
- 하지만 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 종료하면 소멸한다
```
function foo(){
    let x = 'local';
    console.log(x);
    return x;
}
foo();
console.log(x); // ReferenceError: x is not defined
```
지역 변수 x 는 foo 함수가 호출되기 이전까지는 생성되지 않는다 foo 함수를 호출하지 않으면 함수 내부의 변수 선언문이 실행되지 않기 때문이다. 
- 지역 변수의 생명 주기는 함수의 생명주기와 일치한다.
> 지역 변수가 함수보다 오래생존 하는경우
변수의 생명 주기는 메모리 공간확보 -> 메모리 공간 헤제되어 가용메모리 풀에 반환되는 시점까지다.
- 누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.
일반적으로 함수가 종료하면 함수가 생성한 스코프도 소멸한다 하지만 누군가가 **스코프를 참조하고 있다면?** 스코프는 헤제되지 않고 생존하게 된다.
```
var x = 'global';
function foo(){
    console.log(x) //undefined
    var x = 'local';
}
foo();
console.log(x); // global
```
foo 함수 내부에서 선언된 지역 변수 x 는 이미 선언되었고 undefined 로 초기화 되어있다. 따라서 전역 변수 x를 참조하는 것이 아니라 지역변수 x 를 참조해 값을 출력한다 하지만 지역변수는 함수 전체에서 유효하다. **변수 할당문이 실행되기 이전까지는 undefined 값**을 갖는다.

## 전역변수의 생명주기
함수와 달리 전역 코드는 명시적인 호출 없이 실행된다 전역 코드는 함수 호출과 같이 전역코드를 실행하는 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다. 함수는 함수 몸체의 마지막 문 또는 반환문이 실행되면 종료한다. var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다, 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 말한다.
- 브라우저 환경에서의 전역 객체는 window 이므로 var 키워드로 선언한 전역 변수는 window의 프로퍼티이며 window는 웹 페이지를 닫기 전까지 유효하다.

## 전역 변수의 문제점
> 암묵적 결합
전역 변수를 선언한 의도는 전역, 즉 코드를 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것이다.
이는 모든 코드가 전역 변수를 참조하고 변경할수 있는 **암묵적 결합** 을 허용하는 것이다. 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될수 있는 위험성도 높아진다.

> 긴 생명 주기
- 전역 변수는 생명 주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비한다.
``` 
var x = 1;
//..

//..

var x = 100;
console.log(x); // 100
```
지역 변수는 전역 변수보다 생명 주기가 훨씬 짧다. 
> 스코프 체인 상에서 종점에 존재
- 전역 변수의 검색 속도가 가장 느리다.검색 속도의 차이는 그다지 크지않지만 속도의 차이는 분명히 있다.
> 네임스페이스 오염
자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것이다. **동일한 이름으로 명명된 전역 변수나 전역 함수**가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수있다.
